{
	QR_Encode.kn v1.00 (for Kuin v1.01)
		Last Modified: 2014/02/12 19:39:41.

	QRコードライブラリです。
	同梱されている、QR_Sample.knを参考に使用してください。
		Created by Tatt(@tatt61880)
		https://twitter.com/tatt61880
		https://github.com/tatt61880

	下記のサイトの QR_Image_Source.zip を利用させていただきました。
		http://www.psytec.co.jp/freesoft/02/

		ソースコードを提供してくださったことを感謝します。
		上記のライセンスに関しては、
			・本ソフトウェアの配布は自由です。
			・ソースコードの一部または全部の使用、及び改変しての使用を認めます。
			・ソースコードを使用する際に弊社に許可を求める必要はなく、また弊社名の記載も不要です。
		とのこと。

		※このため、コメントにC++のコードとの対応関係を書いている場合があります。
}

const x00: byte8 :: 16#00 $ byte8 {'\x00'}
const x11: byte8 :: 16#11 $ byte8 {'\x11'}
const x20: byte8 :: 16#20 $ byte8 {'\x20'}
const x30: byte8 :: 16#30 $ byte8 {'\x30'}

{誤り訂正レベル}
const QR_LEVEL_L: int :: 0
const QR_LEVEL_M: int :: 1
const QR_LEVEL_Q: int :: 2
const QR_LEVEL_H: int :: 3
{データモード}
const QR_MODE_NUMERAL:  byte8 :: 0 $ byte8
const QR_MODE_ALPHABET: byte8 :: 1 $ byte8
const QR_MODE_8BIT:     byte8 :: 2 $ byte8
const QR_MODE_KANJI:    byte8 :: 3 $ byte8
{バージョン(型番)グループ}
const QR_VRESION_S: int :: 0 { 1 ～  9}
const QR_VRESION_M: int :: 1 {10 ～ 26}
const QR_VRESION_L: int :: 2 {27 ～ 40}

const MAX_ALLCODEWORD:  int :: 3706 {総コードワード数最大値}
const MAX_DATACODEWORD: int :: 2956 {データコードワード最大値(バージョン40-L)}
const MAX_CODEBLOCK:    int ::  153 {ブロックデータコードワード数最大値(ＲＳコードワードを含む)}
const MAX_MODULESIZE:   int ::  177 {一辺モジュール数最大値}

{ビットマップ描画時マージン}
const QR_MARGIN: int :: 4

{QRコードバージョン(型番)関連情報}
{struct QR_VERSIONINFO}
class CQrVersionInfo()
	var nVersionNo: int {バージョン(型番)番号(1～40)}
	var ncAllCodeWord: int {総コードワード数}
	{以下配列添字は誤り訂正率(0 = L, 1 = M, 2 = Q, 3 = H)}
	var ncDataCodeWord: []int {データコードワード数(総コードワード数 - ＲＳコードワード数)}
	var ncAlignPoint: int {アライメントパターン座標数}
	var nAlignPoint: []int {アライメントパターン中心座標}
	var RS_BlockInfo1: []CRS_BlockInfo {ＲＳブロック情報(1)}
	var RS_BlockInfo2: []CRS_BlockInfo {ＲＳブロック情報(2)}
	func Init(nVersionNo: int, ncAllCodeWord: int, ncDataCodeWord: []int, ncAlignPoint: int, nAlignPoint: []int, RS_BlockInfo1: []int, RS_BlockInfo2: []int): @CQrVersionInfo
		do me.nVersionNo :: nVersionNo
		do me.ncAllCodeWord :: ncAllCodeWord
		do me.ncDataCodeWord :: #[4]int
		do me.ncDataCodeWord :: ##ncDataCodeWord
		do me.ncAlignPoint :: ncAlignPoint
		do me.nAlignPoint :: #[6]int
		do me.nAlignPoint :: ##nAlignPoint
		do me.RS_BlockInfo1 :: #[4]CRS_BlockInfo
		do me.RS_BlockInfo2 :: #[4]CRS_BlockInfo
		for i(0, 3)
			do me.RS_BlockInfo1[i] :: (#CRS_BlockInfo).Init(RS_BlockInfo1, 3 * i)
			do me.RS_BlockInfo2[i] :: (#CRS_BlockInfo).Init(RS_BlockInfo2, 3 * i)
		end for
		return me
	end func

	{struct RS_BLOCKINFO}
	class CRS_BlockInfo()
		var ncRSBlock: int {ＲＳブロック数}
		var ncAllCodeWord: int {ブロック内コードワード数}
		var ncDataCodeWord: int {データコードワード数(コードワード数 - ＲＳコードワード数)}
		func Init(RS_BlockInfo: []int, n: int): CRS_BlockInfo
			do me.ncRSBlock :: RS_BlockInfo[n]
			do me.ncAllCodeWord :: RS_BlockInfo[n + 1]
			do me.ncDataCodeWord :: RS_BlockInfo[n + 2]
			return me
		end func
	end class
end class

var QR_VersionInfo: []@CQrVersionInfo
var byExpToInt: []byte8
var byIntToExp: []byte8
var byRSExp7 : []int
var byRSExp10: []int
var byRSExp13: []int
var byRSExp15: []int
var byRSExp16: []int
var byRSExp17: []int
var byRSExp18: []int
var byRSExp20: []int
var byRSExp22: []int
var byRSExp24: []int
var byRSExp26: []int
var byRSExp28: []int
var byRSExp30: []int
var byRSExp32: []int
var byRSExp34: []int
var byRSExp36: []int
var byRSExp38: []int
var byRSExp40: []int
var byRSExp42: []int
var byRSExp44: []int
var byRSExp46: []int
var byRSExp48: []int
var byRSExp50: []int
var byRSExp52: []int
var byRSExp54: []int
var byRSExp56: []int
var byRSExp58: []int
var byRSExp60: []int
var byRSExp62: []int
var byRSExp64: []int
var byRSExp66: []int
var byRSExp68: []int
var byRSExp: [][]int
var nIndicatorLenNumeral: []int
var nIndicatorLenAlphabet: []int
var nIndicatorLen8Bit: []int
var nIndicatorLenKanji: []int

{static変数の初期化用}
var InitializeFlag: bool
func Initialize()
	{QRコードバージョン(型番)情報}
	do @QR_VersionInfo :: #[41]@CQrVersionInfo
	do @QR_VersionInfo[ 1] :: (#@CQrVersionInfo).Init( 1,  26,[  19,  16,  13,   9],0,[ 0, 0, 0,  0,  0,  0],[ 1, 26, 19, 1,26,16, 1,26,13, 1,26, 9],[ 0,  0,  0, 0,0 , 0, 0, 0, 0, 0, 0, 0])
	do @QR_VersionInfo[ 2] :: (#@CQrVersionInfo).Init( 2,  44,[  34,  28,  22,  16],1,[18, 0, 0,  0,  0,  0],[ 1, 44, 34, 1,44,28, 1,44,22, 1,44,16],[ 0,  0,  0, 0,0 , 0, 0, 0, 0, 0, 0, 0])
	do @QR_VersionInfo[ 3] :: (#@CQrVersionInfo).Init( 3,  70,[  55,  44,  34,  26],1,[22, 0, 0,  0,  0,  0],[ 1, 70, 55, 1,70,44, 2,35,17, 2,35,13],[ 0,  0,  0, 0,0 , 0, 0, 0, 0, 0, 0, 0])
	do @QR_VersionInfo[ 4] :: (#@CQrVersionInfo).Init( 4, 100,[  80,  64,  48,  36],1,[26, 0, 0,  0,  0,  0],[ 1,100, 80, 2,50,32, 2,50,24, 4,25, 9],[ 0,  0,  0, 0,0 , 0, 0, 0, 0, 0, 0, 0])
	do @QR_VersionInfo[ 5] :: (#@CQrVersionInfo).Init( 5, 134,[ 108,  86,  62,  46],1,[30, 0, 0,  0,  0,  0],[ 1,134,108, 2,67,43, 2,33,15, 2,33,11],[ 0,  0,  0, 0,0 , 0, 2,34,16, 2,34,12])
	do @QR_VersionInfo[ 6] :: (#@CQrVersionInfo).Init( 6, 172,[ 136, 108,  76,  60],1,[34, 0, 0,  0,  0,  0],[ 2, 86, 68, 4,43,27, 4,43,19, 4,43,15],[ 0,  0,  0, 0,0 , 0, 0, 0, 0, 0, 0, 0])
	do @QR_VersionInfo[ 7] :: (#@CQrVersionInfo).Init( 7, 196,[ 156, 124,  88,  66],2,[22,38, 0,  0,  0,  0],[ 2, 98, 78, 4,49,31, 2,32,14, 4,39,13],[ 0,  0,  0, 0,0 , 0, 4,33,15, 1,40,14])
	do @QR_VersionInfo[ 8] :: (#@CQrVersionInfo).Init( 8, 242,[ 194, 154, 110,  86],2,[24,42, 0,  0,  0,  0],[ 2,121, 97, 2,60,38, 4,40,18, 4,40,14],[ 0,  0,  0, 2,61,39, 2,41,19, 2,41,15])
	do @QR_VersionInfo[ 9] :: (#@CQrVersionInfo).Init( 9, 292,[ 232, 182, 132, 100],2,[26,46, 0,  0,  0,  0],[ 2,146,116, 3,58,36, 4,36,16, 4,36,12],[ 0,  0,  0, 2,59,37, 4,37,17, 4,37,13])
	do @QR_VersionInfo[10] :: (#@CQrVersionInfo).Init(10, 346,[ 274, 216, 154, 122],2,[28,50, 0,  0,  0,  0],[ 2, 86, 68, 4,69,43, 6,43,19, 6,43,15],[ 2, 87, 69, 1,70,44, 2,44,20, 2,44,16])
	do @QR_VersionInfo[11] :: (#@CQrVersionInfo).Init(11, 404,[ 324, 254, 180, 140],2,[30,54, 0,  0,  0,  0],[ 4,101, 81, 1,80,50, 4,50,22, 3,36,12],[ 0,  0,  0, 4,81,51, 4,51,23, 8,37,13])
	do @QR_VersionInfo[12] :: (#@CQrVersionInfo).Init(12, 466,[ 370, 290, 206, 158],2,[32,58, 0,  0,  0,  0],[ 2,116, 92, 6,58,36, 4,46,20, 7,42,14],[ 2,117, 93, 2,59,37, 6,47,21, 4,43,15])
	do @QR_VersionInfo[13] :: (#@CQrVersionInfo).Init(13, 532,[ 428, 334, 244, 180],2,[34,62, 0,  0,  0,  0],[ 4,133,107, 8,59,37, 8,44,20,12,33,11],[ 0,  0,  0, 1,60,38, 4,45,21, 4,34,12])
	do @QR_VersionInfo[14] :: (#@CQrVersionInfo).Init(14, 581,[ 461, 365, 261, 197],3,[26,46,66,  0,  0,  0],[ 3,145,115, 4,64,40,11,36,16,11,36,12],[ 1,146,116, 5,65,41, 5,37,17, 5,37,13])
	do @QR_VersionInfo[15] :: (#@CQrVersionInfo).Init(15, 655,[ 523, 415, 295, 223],3,[26,48,70,  0,  0,  0],[ 5,109, 87, 5,65,41, 5,54,24,11,36,12],[ 1,110, 88, 5,66,42, 7,55,25, 7,37,13])
	do @QR_VersionInfo[16] :: (#@CQrVersionInfo).Init(16, 733,[ 589, 453, 325, 253],3,[26,50,74,  0,  0,  0],[ 5,122, 98, 7,73,45,15,43,19, 3,45,15],[ 1,123, 99, 3,74,46, 2,44,20,13,46,16])
	do @QR_VersionInfo[17] :: (#@CQrVersionInfo).Init(17, 815,[ 647, 507, 367, 283],3,[30,54,78,  0,  0,  0],[ 1,135,107,10,74,46, 1,50,22, 2,42,14],[ 5,136,108, 1,75,47,15,51,23,17,43,15])
	do @QR_VersionInfo[18] :: (#@CQrVersionInfo).Init(18, 901,[ 721, 563, 397, 313],3,[30,56,82,  0,  0,  0],[ 5,150,120, 9,69,43,17,50,22, 2,42,14],[ 1,151,121, 4,70,44, 1,51,23,19,43,15])
	do @QR_VersionInfo[19] :: (#@CQrVersionInfo).Init(19, 991,[ 795, 627, 445, 341],3,[30,58,86,  0,  0,  0],[ 3,141,113, 3,70,44,17,47,21, 9,39,13],[ 4,142,114,11,71,45, 4,48,22,16,40,14])
	do @QR_VersionInfo[20] :: (#@CQrVersionInfo).Init(20,1085,[ 861, 669, 485, 385],3,[34,62,90,  0,  0,  0],[ 3,135,107, 3,67,41,15,54,24,15,43,15],[ 5,136,108,13,68,42, 5,55,25,10,44,16])
	do @QR_VersionInfo[21] :: (#@CQrVersionInfo).Init(21,1156,[ 932, 714, 512, 406],4,[28,50,72, 94,  0,  0],[ 4,144,116,17,68,42,17,50,22,19,46,16],[ 4,145,117, 0, 0, 0, 6,51,23, 6,47,17])
	do @QR_VersionInfo[22] :: (#@CQrVersionInfo).Init(22,1258,[1006, 782, 568, 442],4,[26,50,74, 98,  0,  0],[ 2,139,111,17,74,46, 7,54,24,34,37,13],[ 7,140,112, 0, 0, 0,16,55,25, 0, 0, 0])
	do @QR_VersionInfo[23] :: (#@CQrVersionInfo).Init(23,1364,[1094, 860, 614, 464],4,[30,54,78,102,  0,  0],[ 4,151,121, 4,75,47,11,54,24,16,45,15],[ 5,152,122,14,76,48,14,55,25,14,46,16])
	do @QR_VersionInfo[24] :: (#@CQrVersionInfo).Init(24,1474,[1174, 914, 664, 514],4,[28,54,80,106,  0,  0],[ 6,147,117, 6,73,45,11,54,24,30,46,16],[ 4,148,118,14,74,46,16,55,25, 2,47,17])
	do @QR_VersionInfo[25] :: (#@CQrVersionInfo).Init(25,1588,[1276,1000, 718, 538],4,[32,58,84,110,  0,  0],[ 8,132,106, 8,75,47, 7,54,24,22,45,15],[ 4,133,107,13,76,48,22,55,25,13,46,16])
	do @QR_VersionInfo[26] :: (#@CQrVersionInfo).Init(26,1706,[1370,1062, 754, 596],4,[30,58,86,114,  0,  0],[10,142,114,19,74,46,28,50,22,33,46,16],[ 2,143,115, 4,75,47, 6,51,23, 4,47,17])
	do @QR_VersionInfo[27] :: (#@CQrVersionInfo).Init(27,1828,[1468,1128, 808, 628],4,[34,62,90,118,  0,  0],[ 8,152,122,22,73,45, 8,53,23,12,45,15],[ 4,153,123, 3,74,46,26,54,24,28,46,16])
	do @QR_VersionInfo[28] :: (#@CQrVersionInfo).Init(28,1921,[1531,1193, 871, 661],5,[26,50,74, 98,122,  0],[ 3,147,117, 3,73,45, 4,54,24,11,45,15],[10,148,118,23,74,46,31,55,25,31,46,16])
	do @QR_VersionInfo[29] :: (#@CQrVersionInfo).Init(29,2051,[1631,1267, 911, 701],5,[30,54,78,102,126,  0],[ 7,146,116,21,73,45, 1,53,23,19,45,15],[ 7,147,117, 7,74,46,37,54,24,26,46,16])
	do @QR_VersionInfo[30] :: (#@CQrVersionInfo).Init(30,2185,[1735,1373, 985, 745],5,[26,52,78,104,130,  0],[ 5,145,115,19,75,47,15,54,24,23,45,15],[10,146,116,10,76,48,25,55,25,25,46,16])
	do @QR_VersionInfo[31] :: (#@CQrVersionInfo).Init(31,2323,[1843,1455,1033, 793],5,[30,56,82,108,134,  0],[13,145,115, 2,74,46,42,54,24,23,45,15],[ 3,146,116,29,75,47, 1,55,25,28,46,16])
	do @QR_VersionInfo[32] :: (#@CQrVersionInfo).Init(32,2465,[1955,1541,1115, 845],5,[34,60,86,112,138,  0],[17,145,115,10,74,46,10,54,24,19,45,15],[ 0,  0,  0,23,75,47,35,55,25,35,46,16])
	do @QR_VersionInfo[33] :: (#@CQrVersionInfo).Init(33,2611,[2071,1631,1171, 901],5,[30,58,86,114,142,  0],[17,145,115,14,74,46,29,54,24,11,45,15],[ 1,146,116,21,75,47,19,55,25,46,46,16])
	do @QR_VersionInfo[34] :: (#@CQrVersionInfo).Init(34,2761,[2191,1725,1231, 961],5,[34,62,90,118,146,  0],[13,145,115,14,74,46,44,54,24,59,46,16],[ 6,146,116,23,75,47, 7,55,25, 1,47,17])
	do @QR_VersionInfo[35] :: (#@CQrVersionInfo).Init(35,2876,[2306,1812,1286, 986],6,[30,54,78,102,126,150],[12,151,121,12,75,47,39,54,24,22,45,15],[ 7,152,122,26,76,48,14,55,25,41,46,16])
	do @QR_VersionInfo[36] :: (#@CQrVersionInfo).Init(36,3034,[2434,1914,1354,1054],6,[24,50,76,102,128,154],[ 6,151,121, 6,75,47,46,54,24, 2,45,15],[14,152,122,34,76,48,10,55,25,64,46,16])
	do @QR_VersionInfo[37] :: (#@CQrVersionInfo).Init(37,3196,[2566,1992,1426,1096],6,[28,54,80,106,132,158],[17,152,122,29,74,46,49,54,24,24,45,15],[ 4,153,123,14,75,47,10,55,25,46,46,16])
	do @QR_VersionInfo[38] :: (#@CQrVersionInfo).Init(38,3362,[2702,2102,1502,1142],6,[32,58,84,110,136,162],[ 4,152,122,13,74,46,48,54,24,42,45,15],[18,153,123,32,75,47,14,55,25,32,46,16])
	do @QR_VersionInfo[39] :: (#@CQrVersionInfo).Init(39,3532,[2812,2216,1582,1222],6,[26,54,82,110,138,166],[20,147,117,40,75,47,43,54,24,10,45,15],[ 4,148,118, 7,76,48,22,55,25,67,46,16])
	do @QR_VersionInfo[40] :: (#@CQrVersionInfo).Init(40,3706,[2956,2334,1666,1276],6,[30,58,86,114,142,170],[19,148,118,18,75,47,34,54,24,20,45,15],[ 6,149,119,31,76,48,34,55,25,61,46,16])

	{GF(2^8)α指数→整数変換テーブル}
	do @byExpToInt :: [1 $ byte8,   2 $ byte8,   4 $ byte8,   8 $ byte8,  16 $ byte8,  32 $ byte8,  64 $ byte8, 128 $ byte8,  29 $ byte8,  58 $ byte8, 116 $ byte8, 232 $ byte8, 205 $ byte8, 135 $ byte8,  19 $ byte8,  38 $ byte8, {
				}	  76 $ byte8, 152 $ byte8,  45 $ byte8,  90 $ byte8, 180 $ byte8, 117 $ byte8, 234 $ byte8, 201 $ byte8, 143 $ byte8,   3 $ byte8,   6 $ byte8,  12 $ byte8,  24 $ byte8,  48 $ byte8,  96 $ byte8, 192 $ byte8, {
				}	 157 $ byte8,  39 $ byte8,  78 $ byte8, 156 $ byte8,  37 $ byte8,  74 $ byte8, 148 $ byte8,  53 $ byte8, 106 $ byte8, 212 $ byte8, 181 $ byte8, 119 $ byte8, 238 $ byte8, 193 $ byte8, 159 $ byte8,  35 $ byte8, {
				}	  70 $ byte8, 140 $ byte8,   5 $ byte8,  10 $ byte8,  20 $ byte8,  40 $ byte8,  80 $ byte8, 160 $ byte8,  93 $ byte8, 186 $ byte8, 105 $ byte8, 210 $ byte8, 185 $ byte8, 111 $ byte8, 222 $ byte8, 161 $ byte8, {
				}	  95 $ byte8, 190 $ byte8,  97 $ byte8, 194 $ byte8, 153 $ byte8,  47 $ byte8,  94 $ byte8, 188 $ byte8, 101 $ byte8, 202 $ byte8, 137 $ byte8,  15 $ byte8,  30 $ byte8,  60 $ byte8, 120 $ byte8, 240 $ byte8, {
				}	 253 $ byte8, 231 $ byte8, 211 $ byte8, 187 $ byte8, 107 $ byte8, 214 $ byte8, 177 $ byte8, 127 $ byte8, 254 $ byte8, 225 $ byte8, 223 $ byte8, 163 $ byte8,  91 $ byte8, 182 $ byte8, 113 $ byte8, 226 $ byte8, {
				}	 217 $ byte8, 175 $ byte8,  67 $ byte8, 134 $ byte8,  17 $ byte8,  34 $ byte8,  68 $ byte8, 136 $ byte8,  13 $ byte8,  26 $ byte8,  52 $ byte8, 104 $ byte8, 208 $ byte8, 189 $ byte8, 103 $ byte8, 206 $ byte8, {
				}	 129 $ byte8,  31 $ byte8,  62 $ byte8, 124 $ byte8, 248 $ byte8, 237 $ byte8, 199 $ byte8, 147 $ byte8,  59 $ byte8, 118 $ byte8, 236 $ byte8, 197 $ byte8, 151 $ byte8,  51 $ byte8, 102 $ byte8, 204 $ byte8, {
				}	 133 $ byte8,  23 $ byte8,  46 $ byte8,  92 $ byte8, 184 $ byte8, 109 $ byte8, 218 $ byte8, 169 $ byte8,  79 $ byte8, 158 $ byte8,  33 $ byte8,  66 $ byte8, 132 $ byte8,  21 $ byte8,  42 $ byte8,  84 $ byte8, {
				}	 168 $ byte8,  77 $ byte8, 154 $ byte8,  41 $ byte8,  82 $ byte8, 164 $ byte8,  85 $ byte8, 170 $ byte8,  73 $ byte8, 146 $ byte8,  57 $ byte8, 114 $ byte8, 228 $ byte8, 213 $ byte8, 183 $ byte8, 115 $ byte8, {
				}	 230 $ byte8, 209 $ byte8, 191 $ byte8,  99 $ byte8, 198 $ byte8, 145 $ byte8,  63 $ byte8, 126 $ byte8, 252 $ byte8, 229 $ byte8, 215 $ byte8, 179 $ byte8, 123 $ byte8, 246 $ byte8, 241 $ byte8, 255 $ byte8, {
				}	 227 $ byte8, 219 $ byte8, 171 $ byte8,  75 $ byte8, 150 $ byte8,  49 $ byte8,  98 $ byte8, 196 $ byte8, 149 $ byte8,  55 $ byte8, 110 $ byte8, 220 $ byte8, 165 $ byte8,  87 $ byte8, 174 $ byte8,  65 $ byte8, {
				}	 130 $ byte8,  25 $ byte8,  50 $ byte8, 100 $ byte8, 200 $ byte8, 141 $ byte8,   7 $ byte8,  14 $ byte8,  28 $ byte8,  56 $ byte8, 112 $ byte8, 224 $ byte8, 221 $ byte8, 167 $ byte8,  83 $ byte8, 166 $ byte8, {
				}	  81 $ byte8, 162 $ byte8,  89 $ byte8, 178 $ byte8, 121 $ byte8, 242 $ byte8, 249 $ byte8, 239 $ byte8, 195 $ byte8, 155 $ byte8,  43 $ byte8,  86 $ byte8, 172 $ byte8,  69 $ byte8, 138 $ byte8,   9 $ byte8, {
				}	  18 $ byte8,  36 $ byte8,  72 $ byte8, 144 $ byte8,  61 $ byte8, 122 $ byte8, 244 $ byte8, 245 $ byte8, 247 $ byte8, 243 $ byte8, 251 $ byte8, 235 $ byte8, 203 $ byte8, 139 $ byte8,  11 $ byte8,  22 $ byte8, {
				}	  44 $ byte8,  88 $ byte8, 176 $ byte8, 125 $ byte8, 250 $ byte8, 233 $ byte8, 207 $ byte8, 131 $ byte8,  27 $ byte8,  54 $ byte8, 108 $ byte8, 216 $ byte8, 173 $ byte8,  71 $ byte8, 142 $ byte8,   1 $ byte8]

	{GF(2^8)α整数→指数変換テーブル}
	do @byIntToExp :: [0 $ byte8,   0 $ byte8,   1 $ byte8,  25 $ byte8,   2 $ byte8,  50 $ byte8,  26 $ byte8, 198 $ byte8,   3 $ byte8, 223 $ byte8,  51 $ byte8, 238 $ byte8,  27 $ byte8, 104 $ byte8, 199 $ byte8,  75 $ byte8, {
				}	   4 $ byte8, 100 $ byte8, 224 $ byte8,  14 $ byte8,  52 $ byte8, 141 $ byte8, 239 $ byte8, 129 $ byte8,  28 $ byte8, 193 $ byte8, 105 $ byte8, 248 $ byte8, 200 $ byte8,   8 $ byte8,  76 $ byte8, 113 $ byte8, {
				}	   5 $ byte8, 138 $ byte8, 101 $ byte8,  47 $ byte8, 225 $ byte8,  36 $ byte8,  15 $ byte8,  33 $ byte8,  53 $ byte8, 147 $ byte8, 142 $ byte8, 218 $ byte8, 240 $ byte8,  18 $ byte8, 130 $ byte8,  69 $ byte8, {
				}	  29 $ byte8, 181 $ byte8, 194 $ byte8, 125 $ byte8, 106 $ byte8,  39 $ byte8, 249 $ byte8, 185 $ byte8, 201 $ byte8, 154 $ byte8,   9 $ byte8, 120 $ byte8,  77 $ byte8, 228 $ byte8, 114 $ byte8, 166 $ byte8, {
				}	   6 $ byte8, 191 $ byte8, 139 $ byte8,  98 $ byte8, 102 $ byte8, 221 $ byte8,  48 $ byte8, 253 $ byte8, 226 $ byte8, 152 $ byte8,  37 $ byte8, 179 $ byte8,  16 $ byte8, 145 $ byte8,  34 $ byte8, 136 $ byte8, {
				}	  54 $ byte8, 208 $ byte8, 148 $ byte8, 206 $ byte8, 143 $ byte8, 150 $ byte8, 219 $ byte8, 189 $ byte8, 241 $ byte8, 210 $ byte8,  19 $ byte8,  92 $ byte8, 131 $ byte8,  56 $ byte8,  70 $ byte8,  64 $ byte8, {
				}	  30 $ byte8,  66 $ byte8, 182 $ byte8, 163 $ byte8, 195 $ byte8,  72 $ byte8, 126 $ byte8, 110 $ byte8, 107 $ byte8,  58 $ byte8,  40 $ byte8,  84 $ byte8, 250 $ byte8, 133 $ byte8, 186 $ byte8,  61 $ byte8, {
				}	 202 $ byte8,  94 $ byte8, 155 $ byte8, 159 $ byte8,  10 $ byte8,  21 $ byte8, 121 $ byte8,  43 $ byte8,  78 $ byte8, 212 $ byte8, 229 $ byte8, 172 $ byte8, 115 $ byte8, 243 $ byte8, 167 $ byte8,  87 $ byte8, {
				}	   7 $ byte8, 112 $ byte8, 192 $ byte8, 247 $ byte8, 140 $ byte8, 128 $ byte8,  99 $ byte8,  13 $ byte8, 103 $ byte8,  74 $ byte8, 222 $ byte8, 237 $ byte8,  49 $ byte8, 197 $ byte8, 254 $ byte8,  24 $ byte8, {
				}	 227 $ byte8, 165 $ byte8, 153 $ byte8, 119 $ byte8,  38 $ byte8, 184 $ byte8, 180 $ byte8, 124 $ byte8,  17 $ byte8,  68 $ byte8, 146 $ byte8, 217 $ byte8,  35 $ byte8,  32 $ byte8, 137 $ byte8,  46 $ byte8, {
				}	  55 $ byte8,  63 $ byte8, 209 $ byte8,  91 $ byte8, 149 $ byte8, 188 $ byte8, 207 $ byte8, 205 $ byte8, 144 $ byte8, 135 $ byte8, 151 $ byte8, 178 $ byte8, 220 $ byte8, 252 $ byte8, 190 $ byte8,  97 $ byte8, {
				}	 242 $ byte8,  86 $ byte8, 211 $ byte8, 171 $ byte8,  20 $ byte8,  42 $ byte8,  93 $ byte8, 158 $ byte8, 132 $ byte8,  60 $ byte8,  57 $ byte8,  83 $ byte8,  71 $ byte8, 109 $ byte8,  65 $ byte8, 162 $ byte8, {
				}	  31 $ byte8,  45 $ byte8,  67 $ byte8, 216 $ byte8, 183 $ byte8, 123 $ byte8, 164 $ byte8, 118 $ byte8, 196 $ byte8,  23 $ byte8,  73 $ byte8, 236 $ byte8, 127 $ byte8,  12 $ byte8, 111 $ byte8, 246 $ byte8, {
				}	 108 $ byte8, 161 $ byte8,  59 $ byte8,  82 $ byte8,  41 $ byte8, 157 $ byte8,  85 $ byte8, 170 $ byte8, 251 $ byte8,  96 $ byte8, 134 $ byte8, 177 $ byte8, 187 $ byte8, 204 $ byte8,  62 $ byte8,  90 $ byte8, {
				}	 203 $ byte8,  89 $ byte8,  95 $ byte8, 176 $ byte8, 156 $ byte8, 169 $ byte8, 160 $ byte8,  81 $ byte8,  11 $ byte8, 245 $ byte8,  22 $ byte8, 235 $ byte8, 122 $ byte8, 117 $ byte8,  44 $ byte8, 215 $ byte8, {
				}	  79 $ byte8, 174 $ byte8, 213 $ byte8, 233 $ byte8, 230 $ byte8, 231 $ byte8, 173 $ byte8, 232 $ byte8, 116 $ byte8, 214 $ byte8, 244 $ byte8, 234 $ byte8, 168 $ byte8,  80 $ byte8,  88 $ byte8, 175 $ byte8]

	{誤り訂正生成多項式α係数}
	do @byRSExp7  :: [ 87,229,146,149,238,102, 21]
	do @byRSExp10 :: [251, 67, 46, 61,118, 70, 64, 94, 32, 45]
	do @byRSExp13 :: [ 74,152,176,100, 86,100,106,104,130,218,206,140, 78]
	do @byRSExp15 :: [  8,183, 61, 91,202, 37, 51, 58, 58,237,140,124,  5, 99,105]
	do @byRSExp16 :: [120,104,107,109,102,161, 76,  3, 91,191,147,169,182,194,225,120]
	do @byRSExp17 :: [ 43,139,206, 78, 43,239,123,206,214,147, 24, 99,150, 39,243,163,136]
	do @byRSExp18 :: [215,234,158, 94,184, 97,118,170, 79,187,152,148,252,179,  5, 98, 96,153]
	do @byRSExp20 :: [ 17, 60, 79, 50, 61,163, 26,187,202,180,221,225, 83,239,156,164,212,212,188,190]
	do @byRSExp22 :: [210,171,247,242, 93,230, 14,109,221, 53,200, 74,  8,172, 98, 80,219,134,160,105,165,231]
	do @byRSExp24 :: [229,121,135, 48,211,117,251,126,159,180,169,152,192,226,228,218,111,  0,117,232, 87, 96,227, 21]
	do @byRSExp26 :: [173,125,158,  2,103,182,118, 17,145,201,111, 28,165, 53,161, 21,245,142, 13,102, 48,227,153,145,218, 70]
	do @byRSExp28 :: [168,223,200,104,224,234,108,180,110,190,195,147,205, 27,232,201, 21, 43,245, 87, 42,195,212,119,242, 37,  9,123]
	do @byRSExp30 :: [ 41,173,145,152,216, 31,179,182, 50, 48,110, 86,239, 96,222,125, 42,173,226,193,224,130,156, 37,251,216,238, 40,192,180]
	do @byRSExp32 :: [ 10,  6,106,190,249,167,  4, 67,209,138,138, 32,242,123, 89, 27,120,185, 80,156, 38, 69,171, 60, 28,222, 80, 52,254,185,220,241]
	do @byRSExp34 :: [111, 77,146, 94, 26, 21,108, 19,105, 94,113,193, 86,140,163,125, 58,158,229,239,218,103, 56, 70,114, 61,183,129,167, 13, 98, 62,129, 51]
	do @byRSExp36 :: [200,183, 98, 16,172, 31,246,234, 60,152,115,  0,167,152,113,248,238,107, 18, 63,218, 37, 87,210,105,177,120, 74,121,196,117,251,113,233, 30,120]
	do @byRSExp38 :: [159, 34, 38,228,230, 59,243, 95, 49,218,176,164, 20, 65, 45,111, 39, 81, 49,118,113,222,193,250,242,168,217, 41,164,247,177, 30,238, 18,120,153, 60,193]
	do @byRSExp40 :: [ 59,116, 79,161,252, 98,128,205,128,161,247, 57,163, 56,235,106, 53, 26,187,174,226,104,170,  7,175, 35,181,114, 88, 41, 47,163,125,134, 72, 20,232, 53, 35, 15]
	do @byRSExp42 :: [250,103,221,230, 25, 18,137,231,  0,  3, 58,242,221,191,110, 84,230,  8,188,106, 96,147, 15,131,139, 34,101,223, 39,101,213,199,237,254,201,123,171,162,194,117, 50, 96]
	do @byRSExp44 :: [190,  7, 61,121, 71,246, 69, 55,168,188, 89,243,191, 25, 72,123,  9,145, 14,247,  1,238, 44, 78,143, 62,224,126,118,114, 68,163, 52,194,217,147,204,169, 37,130,113,102, 73,181]
	do @byRSExp46 :: [112, 94, 88,112,253,224,202,115,187, 99, 89,  5, 54,113,129, 44, 58, 16,135,216,169,211, 36,  1,  4, 96, 60,241, 73,104,234,  8,249,245,119,174, 52, 25,157,224, 43,202,223, 19, 82, 15]
	do @byRSExp48 :: [228, 25,196,130,211,146, 60, 24,251, 90, 39,102,240, 61,178, 63, 46,123,115, 18,221,111,135,160,182,205,107,206, 95,150,120,184, 91, 21,247,156,140,238,191, 11, 94,227, 84, 50,163, 39, 34,108]
	do @byRSExp50 :: [232,125,157,161,164,  9,118, 46,209, 99,203,193, 35,  3,209,111,195,242,203,225, 46, 13, 32,160,126,209,130,160,242,215,242, 75, 77, 42,189, 32,113, 65,124, 69,228,114,235,175,124,170,215,232,133,205]
	do @byRSExp52 :: [116, 50, 86,186, 50,220,251, 89,192, 46, 86,127,124, 19,184,233,151,215, 22, 14, 59,145, 37,242,203,134,254, 89,190, 94, 59, 65,124,113,100,233,235,121, 22, 76, 86, 97, 39,242,200,220,101, 33,239,254,116, 51]
	do @byRSExp54 :: [183, 26,201, 87,210,221,113, 21, 46, 65, 45, 50,238,184,249,225,102, 58,209,218,109,165, 26, 95,184,192, 52,245, 35,254,238,175,172, 79,123, 25,122, 43,120,108,215, 80,128,201,235,  8,153, 59,101, 31,198, 76, 31,156]
	do @byRSExp56 :: [106,120,107,157,164,216,112,116,  2, 91,248,163, 36,201,202,229,  6,144,254,155,135,208,170,209, 12,139,127,142,182,249,177,174,190, 28, 10, 85,239,184,101,124,152,206, 96, 23,163, 61, 27,196,247,151,154,202,207, 20, 61, 10]
	do @byRSExp58 :: [ 82,116, 26,247, 66, 27, 62,107,252,182,200,185,235, 55,251,242,210,144,154,237,176,141,192,248,152,249,206, 85,253,142, 65,165,125, 23, 24, 30,122,240,214,  6,129,218, 29,145,127,134,206,245,117, 29, 41, 63,159,142,233,125,148,123]
	do @byRSExp60 :: [107,140, 26, 12,  9,141,243,197,226,197,219, 45,211,101,219,120, 28,181,127,  6,100,247,  2,205,198, 57,115,219,101,109,160, 82, 37, 38,238, 49,160,209,121, 86, 11,124, 30,181, 84, 25,194, 87, 65,102,190,220, 70, 27,209, 16, 89,  7, 33,240]
	do @byRSExp62 :: [ 65,202,113, 98, 71,223,248,118,214, 94,  0,122, 37, 23,  2,228, 58,121,  7,105,135, 78,243,118, 70, 76,223, 89, 72, 50, 70,111,194, 17,212,126,181, 35,221,117,235, 11,229,149,147,123,213, 40,115,  6,200,100, 26,246,182,218,127,215, 36,186,110,106]
	do @byRSExp64 :: [ 45, 51,175,  9,  7,158,159, 49, 68,119, 92,123,177,204,187,254,200, 78,141,149,119, 26,127, 53,160, 93,199,212, 29, 24,145,156,208,150,218,209,  4,216, 91, 47,184,146, 47,140,195,195,125,242,238, 63, 99,108,140,230,242, 31,204, 11,178,243,217,156,213,231]
	do @byRSExp66 :: [  5,118,222,180,136,136,162, 51, 46,117, 13,215, 81, 17,139,247,197,171, 95,173, 65,137,178, 68,111, 95,101, 41, 72,214,169,197, 95,  7, 44,154, 77,111,236, 40,121,143, 63, 87, 80,253,240,126,217, 77, 34,232,106, 50,168, 82, 76,146, 67,106,171, 25,132, 93, 45,105]
	do @byRSExp68 :: [247,159,223, 33,224, 93, 77, 70, 90,160, 32,254, 43,150, 84,101,190,205,133, 52, 60,202,165,220,203,151, 93, 84, 15, 84,253,173,160, 89,227, 52,199, 97, 95,231, 52,177, 41,125,137,241,166,225,118,  2, 54, 32, 82,215,175,198, 43,238,235, 27,101,184,127,  3,  5,  8,163,238]
	do @byRSExp :: [      null, null,       null,       null,       null,       null,       null,  @byRSExp7,       null, null, {
				}   @byRSExp10, null,       null, @byRSExp13,       null, @byRSExp15, @byRSExp16, @byRSExp17, @byRSExp18, null, {
				}   @byRSExp20, null, @byRSExp22,       null, @byRSExp24,       null, @byRSExp26,       null, @byRSExp28, null, {
				}   @byRSExp30, null, @byRSExp32,       null, @byRSExp34,       null, @byRSExp36,       null, @byRSExp38, null, {
				}   @byRSExp40, null, @byRSExp42,       null, @byRSExp44,       null, @byRSExp46,       null, @byRSExp48, null, {
				}   @byRSExp50, null, @byRSExp52,       null, @byRSExp54,       null, @byRSExp56,       null, @byRSExp58, null, {
				}   @byRSExp60, null, @byRSExp62,       null, @byRSExp64,       null, @byRSExp66,       null, @byRSExp68]

	{文字数インジケータビット長(バージョングループ別, {S, M, L})}
	do @nIndicatorLenNumeral  :: [10, 12, 14]
	do @nIndicatorLenAlphabet :: [ 9, 11, 13]
	do @nIndicatorLen8Bit     :: [ 8, 16, 16]
	do @nIndicatorLenKanji    :: [ 8, 10, 12]
end func

class CQR_Encode()
	var m_nLevel: int {誤り訂正レベル}
	var m_nVersion: int {バージョン(型番)}
	var m_bAutoExtent: int {バージョン(型番)自動拡張指定フラグ}
	var m_nMaskingNo: int {マスキングパターン番号}

	var m_nSymbleSize: int
	var m_byModuleData: [][]byte8 {[x][y]}
	{
	 bit5:機能モジュール（マスキング対象外）フラグ
	 bit4:機能モジュール描画データ
	 bit1:エンコードデータ
	 bit0:マスク後エンコード描画データ
	 20hとの論理和により機能モジュール判定、11hとの論理和により描画（最終的にはBOOL値化）
	}

	-var m_ncDataCodeWordBit: int {データコードワードビット長}
	-var m_byDataCodeWord: []byte8 {入力データエンコードエリア}

	-var m_ncDataBlock: int
	-var m_byBlockMode: []byte8
	-var m_nBlockLength: []int

	-var m_ncAllCodeWord: int {総コードワード数(ＲＳ誤り訂正データを含む)}
	-var m_byAllCodeWord: []byte8 {総コードワード算出エリア}
	-var m_byRSWork: []byte8 {ＲＳコードワード算出ワーク}

	-func Init(): @CQR_Encode
		if(@InitializeFlag = false)
			do @InitializeFlag :: true
			do @Initialize()
		end if
		do me.m_nLevel :: 0
		do me.m_nVersion :: 0
		do me.m_bAutoExtent :: 0
		do me.m_nMaskingNo :: 0

		do me.m_nSymbleSize :: 0
		do me.m_byModuleData :: #[@MAX_MODULESIZE, @MAX_MODULESIZE]byte8

		do me.m_ncDataCodeWordBit :: 0
		do me.m_byDataCodeWord :: #[@MAX_DATACODEWORD]byte8

		do me.m_ncDataBlock :: 0
		do me.m_byBlockMode :: #[@MAX_DATACODEWORD]byte8
		do me.m_nBlockLength :: #[@MAX_DATACODEWORD]int

		do me.m_ncAllCodeWord :: 0
		do me.m_byAllCodeWord :: #[@MAX_ALLCODEWORD]byte8
		do me.m_byRSWork :: #[@MAX_CODEBLOCK]byte8
		return me
	end func

	{
	用  途：データエンコード
	引  数：誤り訂正レベル、型番(0=自動)、型番自動拡張フラグ、マスキング番号(-1=自動)、エンコードしたいデータ、エンコードしたいデータの長さ(0=自動)
	戻り値：エンコード成功時=true、データなし、または容量オーバー時=false
	}
	func EncodeData(nLevel: int, nVersion: int, bAutoExtent: bool, nMaskingNo: int, lpsSource: []byte8, ncSource: int): bool
		do me.Init()
		do me.m_nLevel :: nLevel
		do me.m_nMaskingNo :: nMaskingNo

		{データ長が指定されていない場合は lstrlen によって取得}
		var ncLength: int :: ncSource > 0 ?(ncSource, lpsSource.Len())

		if(ncLength = 0)
			return false {データなし}
		end if

		{バージョン(型番)チェック}
		var nEncodeVersion: int :: me.GetEncodeVersion(nVersion, lpsSource, ncLength)

		if(nEncodeVersion = 0)
			return false {容量オーバー}
		end if

		if(nVersion = 0)
			{型番自動}
			do me.m_nVersion :: nEncodeVersion
		else
			if(nEncodeVersion <= nVersion)
				do me.m_nVersion :: nVersion
			else
				if(bAutoExtent)
					do me.m_nVersion :: nEncodeVersion {バージョン(型番)自動拡張}
				else
					return false {容量オーバー}
				end if
			end if
		end if

		{ターミネータコード"0000"付加}
		var ncDataCodeWord: int :: @QR_VersionInfo[me.m_nVersion].ncDataCodeWord[nLevel]
		var ncTerminater: int :: @min(4, (ncDataCodeWord * 8) - me.m_ncDataCodeWordBit)

		if(ncTerminater > 0)
			do me.m_ncDataCodeWordBit :: me.SetBitStream(me.m_ncDataCodeWordBit, 0 $ byte16, ncTerminater)
		end if

		{パディングコード"11101100, 00010001"付加}
		var byPaddingCode: byte8 :: 16#ec $ byte8

		for i((me.m_ncDataCodeWordBit + 7) / 8, ncDataCodeWord - 1)
			do me.m_byDataCodeWord[i] :: byPaddingCode
			do byPaddingCode :: ((byPaddingCode = 16#ec $ byte8) ?(@x11, 16#ec $ byte8))
		end for

		{総コードワード算出エリアクリア}
		do me.m_ncAllCodeWord :: @QR_VersionInfo[me.m_nVersion].ncAllCodeWord
		{ do ZeroMemory(me.m_byAllCodeWord, me.m_ncAllCodeWord) }
		do me.m_byAllCodeWord :: #[@MAX_ALLCODEWORD]byte8 {総コードワード算出エリア}

		var nDataCwIndex: int :: 0 {データコードワード処理位置}

		{データブロック分割数}
		var ncBlock1: int :: @QR_VersionInfo[me.m_nVersion].RS_BlockInfo1[nLevel].ncRSBlock
		var ncBlock2: int :: @QR_VersionInfo[me.m_nVersion].RS_BlockInfo2[nLevel].ncRSBlock
		var ncBlockSum: int :: ncBlock1 + ncBlock2

		var nBlockNo: int :: 0 {処理中ブロック番号}

		{ブロック別データコードワード数}
		var ncDataCw1: int :: @QR_VersionInfo[me.m_nVersion].RS_BlockInfo1[nLevel].ncDataCodeWord
		var ncDataCw2: int :: @QR_VersionInfo[me.m_nVersion].RS_BlockInfo2[nLevel].ncDataCodeWord

		{データコードワードインターリーブ配置}
		for i(0, ncBlock1 - 1)
			for j(0, ncDataCw1 - 1)
				do me.m_byAllCodeWord[(ncBlockSum * j) + nBlockNo] :: me.m_byDataCodeWord[nDataCwIndex]
				do nDataCwIndex :+ 1
			end for
			do nBlockNo :+ 1
		end for

		for i(0, ncBlock2 - 1)
			for j(0, ncDataCw2 - 1)
				if(j < ncDataCw1)
					do me.m_byAllCodeWord[(ncBlockSum * j) + nBlockNo] :: me.m_byDataCodeWord[nDataCwIndex]
				else
					{２種目ブロック端数分配置}
					do me.m_byAllCodeWord[(ncBlockSum * ncDataCw1) + i] :: me.m_byDataCodeWord[nDataCwIndex]
				end if
				do nDataCwIndex :+ 1
			end for
			do nBlockNo :+ 1
		end for

		{ブロック別ＲＳコードワード数(※現状では同数)}
		var ncRSCw1: int :: @QR_VersionInfo[me.m_nVersion].RS_BlockInfo1[nLevel].ncAllCodeWord - ncDataCw1
		var ncRSCw2: int :: @QR_VersionInfo[me.m_nVersion].RS_BlockInfo2[nLevel].ncAllCodeWord - ncDataCw2

		{ＲＳコードワード算出}
		do nDataCwIndex :: 0
		do nBlockNo :: 0

		for i(0, ncBlock1 - 1)
			{ do ZeroMemory(me.m_byRSWork, sizeof(me.m_byRSWork)) }
			do me.m_byRSWork :: #[@MAX_CODEBLOCK]byte8 {ＲＳコードワード算出ワーク}
			do @memmove(me.m_byRSWork, me.m_byDataCodeWord, nDataCwIndex, ncDataCw1)
			do me.GetRSCodeWord(me.m_byRSWork, ncDataCw1, ncRSCw1)

			{ＲＳコードワード配置}
			for j(0, ncRSCw1 - 1)
				do me.m_byAllCodeWord[ncDataCodeWord + (ncBlockSum * j) + nBlockNo] :: me.m_byRSWork[j]
			end for

			do nDataCwIndex :+ ncDataCw1
			do nBlockNo :+ 1
		end for

		for i(0, ncBlock2 - 1)
			{ do ZeroMemory(me.m_byRSWork, sizeof(me.m_byRSWork)) }
			do me.m_byRSWork :: #[@MAX_CODEBLOCK]byte8 {ＲＳコードワード算出ワーク}
			do @memmove(me.m_byRSWork, me.m_byDataCodeWord, nDataCwIndex, ncDataCw2)
			do me.GetRSCodeWord(me.m_byRSWork, ncDataCw2, ncRSCw2)

			{ＲＳコードワード配置}
			for j(0, ncRSCw2 - 1)
				do me.m_byAllCodeWord[ncDataCodeWord + (ncBlockSum * j) + nBlockNo] :: me.m_byRSWork[j]
			end for

			do nDataCwIndex :+ ncDataCw2
			do nBlockNo :+ 1
		end for

		do me.m_nSymbleSize :: me.m_nVersion * 4 + 17

		{モジュール配置}
		do me.FormatModule()
		return true
	end func

	{
	用  途：エンコード時バージョン(型番)取得
	引  数：調査開始バージョン、エンコードデータ、エンコードデータ長
	戻り値：バージョン番号（容量オーバー時=0）
	}
	-func GetEncodeVersion(nVersion: int, lpsSource: []byte8, ncLength: int): int
		var nVerGroup: int :: nVersion >= 27 ?(@QR_VRESION_L, (nVersion >= 10 ?(@QR_VRESION_M, @QR_VRESION_S)))

		for i(nVerGroup, @QR_VRESION_L)
			if(me.EncodeSourceData(lpsSource, ncLength, i))
				if(i = @QR_VRESION_S)
					for j(1, 9)
						if((me.m_ncDataCodeWordBit + 7) / 8 <= @QR_VersionInfo[j].ncDataCodeWord[me.m_nLevel])
							return j
						end if
					end for
				elif(i = @QR_VRESION_M)
					for j(10, 26)
						if((me.m_ncDataCodeWordBit + 7) / 8 <= @QR_VersionInfo[j].ncDataCodeWord[me.m_nLevel])
							return j
						end if
					end for
				elif(i = @QR_VRESION_L)
					for j(27, 40)
						if((me.m_ncDataCodeWordBit + 7) / 8 <= @QR_VersionInfo[j].ncDataCodeWord[me.m_nLevel])
							return j
						end if
					end for
				end if
			end if
		end for

		return 0
	end func

	{
	用  途：入力データエンコード
	引  数：入力データ、入力データ長、バージョン(型番)グループ
	戻り値：エンコード成功時=true
	}
	-func EncodeSourceData(lpsSource: []byte8, ncLength: int, nVerGroup: int): bool
		{ do ZeroMemory(me.m_nBlockLength, sizeof(me.m_nBlockLength)) }
		do me.m_nBlockLength :: #[@MAX_DATACODEWORD]int

		{どのモードが何文字(バイト)継続しているかを調査}
		do me.m_ncDataBlock :: 0
		for i(0, ncLength - 1)
			var byMode: byte8
			if(i < ncLength - 1 & me.IsKanjiData(lpsSource[i], lpsSource[i + 1]))
				do byMode :: @QR_MODE_KANJI
			elif(me.IsNumeralData(lpsSource[i]))
				do byMode :: @QR_MODE_NUMERAL
			elif(me.IsAlphabetData(lpsSource[i]))
				do byMode :: @QR_MODE_ALPHABET
			else
				do byMode :: @QR_MODE_8BIT
			end if

			if(i = 0)
				do me.m_byBlockMode[0] :: byMode
			end if

			if(me.m_byBlockMode[me.m_ncDataBlock] <> byMode)
				do me.m_ncDataBlock :+ 1
				do me.m_byBlockMode[me.m_ncDataBlock] :: byMode
			end if

			if(byMode = @QR_MODE_KANJI)
				do me.m_nBlockLength[me.m_ncDataBlock] :+ 2
				do i :+ 1
			else
				do me.m_nBlockLength[me.m_ncDataBlock] :+ 1
			end if
		end for

		do me.m_ncDataBlock :+ 1

		{隣接する英数字モードブロックと数字モードブロックの並びをを条件により結合}
		var ncSrcBits: int {元のビット長}
		var ncDstBits: int {単一の英数字モードブロック化した場合のビット長}
		var nBlock: int :: 0
		while a(nBlock < me.m_ncDataBlock - 1)
			var ncJoinFront:   int {前８ビットバイトモードブロックと結合した場合のビット長}
			var ncJoinBehind:  int {後８ビットバイトモードブロックと結合した場合のビット長}
			var nJoinPosition: int :: 0 {８ビットバイトモードブロックとの結合：-1=前と結合、0=結合しない、1=後ろと結合}

			{「数字－英数字」または「英数字－数字」の並び}
			if((me.m_byBlockMode[nBlock] = @QR_MODE_NUMERAL  & me.m_byBlockMode[nBlock + 1] = @QR_MODE_ALPHABET) | {
				} (me.m_byBlockMode[nBlock] = @QR_MODE_ALPHABET & me.m_byBlockMode[nBlock + 1] = @QR_MODE_NUMERAL))
				{元のビット長と単一の英数字モードブロック化した場合のビット長を比較}
				do ncSrcBits :: me.GetBitLength(me.m_byBlockMode[nBlock], me.m_nBlockLength[nBlock], nVerGroup) + {
				} me.GetBitLength(me.m_byBlockMode[nBlock + 1], me.m_nBlockLength[nBlock + 1], nVerGroup)
				do ncDstBits :: me.GetBitLength(@QR_MODE_ALPHABET, me.m_nBlockLength[nBlock] + me.m_nBlockLength[nBlock + 1], nVerGroup)
				if(ncSrcBits > ncDstBits)
					{前後に８ビットバイトモードブロックがある場合、それらとの結合が有利かどうかをチェック}
					if(nBlock >= 1 & me.m_byBlockMode[nBlock - 1] = @QR_MODE_8BIT)
						{前に８ビットバイトモードブロックあり}
						do ncJoinFront :: me.GetBitLength(@QR_MODE_8BIT, me.m_nBlockLength[nBlock - 1] + me.m_nBlockLength[nBlock], nVerGroup) + {
						} me.GetBitLength(me.m_byBlockMode[nBlock + 1], me.m_nBlockLength[nBlock + 1], nVerGroup)

						if(ncJoinFront > ncDstBits + me.GetBitLength(@QR_MODE_8BIT, me.m_nBlockLength[nBlock - 1], nVerGroup))
							do ncJoinFront :: 0 {８ビットバイトモードブロックとは結合しない}
						end if
					else
						do ncJoinFront :: 0
					end if

					if(nBlock < me.m_ncDataBlock - 2 & me.m_byBlockMode[nBlock + 2] = @QR_MODE_8BIT)
						{後ろに８ビットバイトモードブロックあり}
						do ncJoinBehind :: me.GetBitLength(me.m_byBlockMode[nBlock], me.m_nBlockLength[nBlock], nVerGroup) + {
						} me.GetBitLength(@QR_MODE_8BIT, me.m_nBlockLength[nBlock + 1] + me.m_nBlockLength[nBlock + 2], nVerGroup)

						if(ncJoinBehind > ncDstBits + me.GetBitLength(@QR_MODE_8BIT, me.m_nBlockLength[nBlock + 2], nVerGroup))
							do ncJoinBehind :: 0 {８ビットバイトモードブロックとは結合しない}
						end if
					else
						do ncJoinBehind :: 0
					end if

					if(ncJoinFront <> 0 & ncJoinBehind <> 0)
						{前後両方に８ビットバイトモードブロックがある場合はデータ長が短くなる方を優先}
						do nJoinPosition :: (ncJoinFront < ncJoinBehind) ?(-1, 1)
					else
						do nJoinPosition :: (ncJoinFront <> 0) ?(-1, (ncJoinBehind <> 0) ?(1, 0))
					end if

					if(nJoinPosition <> 0)
						{８ビットバイトモードブロックとの結合}
						if(nJoinPosition = -1)
							do me.m_nBlockLength[nBlock - 1] :+ me.m_nBlockLength[nBlock]

							{後続をシフト}
							for i(nBlock, me.m_ncDataBlock - 2)
								do me.m_byBlockMode[i]  :: me.m_byBlockMode[i + 1]
								do me.m_nBlockLength[i] :: me.m_nBlockLength[i + 1]
							end for
						else
							do me.m_byBlockMode[nBlock + 1] :: @QR_MODE_8BIT
							do me.m_nBlockLength[nBlock + 1] :+ me.m_nBlockLength[nBlock + 2]

							{後続をシフト}
							for i(nBlock + 2, me.m_ncDataBlock - 2)
								do me.m_byBlockMode[i]  :: me.m_byBlockMode[i + 1]
								do me.m_nBlockLength[i] :: me.m_nBlockLength[i + 1]
							end for
						end if
						do me.m_ncDataBlock :- 1
					else
						{英数字と数字の並びを単一の英数字モードブロックに統合}
						if(nBlock < me.m_ncDataBlock - 2 & me.m_byBlockMode[nBlock + 2] = @QR_MODE_ALPHABET)
							{結合しようとするブロックの後ろに続く英数字モードブロックを結合}
							do me.m_nBlockLength[nBlock + 1] :+ me.m_nBlockLength[nBlock + 2]
							{後続をシフト}
							for i(nBlock + 2, me.m_ncDataBlock - 2)
								do me.m_byBlockMode[i]  :: me.m_byBlockMode[i + 1]
								do me.m_nBlockLength[i] :: me.m_nBlockLength[i + 1]
							end for
							do me.m_ncDataBlock :- 1
						end if

						do me.m_byBlockMode[nBlock] :: @QR_MODE_ALPHABET
						do me.m_nBlockLength[nBlock] :+ me.m_nBlockLength[nBlock + 1]

						{後続をシフト}
						for i(nBlock + 1, me.m_ncDataBlock - 2)
							do me.m_byBlockMode[i]  :: me.m_byBlockMode[i + 1]
							do me.m_nBlockLength[i] :: me.m_nBlockLength[i + 1]
						end for

						do me.m_ncDataBlock :- 1

						if(nBlock >= 1 & me.m_byBlockMode[nBlock - 1] = @QR_MODE_ALPHABET)
							{結合したブロックの前の英数字モードブロックを結合}
							do me.m_nBlockLength[nBlock - 1] :+ me.m_nBlockLength[nBlock]

							{後続をシフト}
							for i(nBlock, me.m_ncDataBlock - 2)
								do me.m_byBlockMode[i]  :: me.m_byBlockMode[i + 1]
								do me.m_nBlockLength[i] :: me.m_nBlockLength[i + 1]
							end for

							do me.m_ncDataBlock :- 1
						end if
					end if

					continue a {現在位置のブロックを再調査}
				end if
			end if

			do nBlock :+ 1 {次ブロックを調査}
		end while

		{連続する短いモードブロックを８ビットバイトモードブロック化}
		do nBlock :: 0
		while a(nBlock < me.m_ncDataBlock - 1)
			do ncSrcBits :: me.GetBitLength(me.m_byBlockMode[nBlock], me.m_nBlockLength[nBlock    ], nVerGroup) {
			} + me.GetBitLength(me.m_byBlockMode[nBlock + 1], me.m_nBlockLength[nBlock + 1], nVerGroup)
			do ncDstBits :: me.GetBitLength(@QR_MODE_8BIT, me.m_nBlockLength[nBlock] + me.m_nBlockLength[nBlock + 1], nVerGroup)

			{前に８ビットバイトモードブロックがある場合、重複するインジケータ分を減算}
			if(nBlock >= 1 & me.m_byBlockMode[nBlock - 1] = @QR_MODE_8BIT)
				do ncDstBits :- (4 + @nIndicatorLen8Bit[nVerGroup])
			end if

			{後ろに８ビットバイトモードブロックがある場合、重複するインジケータ分を減算}
			if(nBlock < me.m_ncDataBlock - 2 & me.m_byBlockMode[nBlock + 2] = @QR_MODE_8BIT)
				do ncDstBits :- (4 + @nIndicatorLen8Bit[nVerGroup])
			end if

			if(ncSrcBits > ncDstBits)
				if(nBlock >= 1 & me.m_byBlockMode[nBlock - 1] = @QR_MODE_8BIT)
					{結合するブロックの前にある８ビットバイトモードブロックを結合}
					do me.m_nBlockLength[nBlock - 1] :+ me.m_nBlockLength[nBlock]

					{後続をシフト}
					for i(nBlock, me.m_ncDataBlock - 2)
						do me.m_byBlockMode[i]  :: me.m_byBlockMode[i + 1]
						do me.m_nBlockLength[i] :: me.m_nBlockLength[i + 1]
					end for

					do me.m_ncDataBlock :- 1
					do nBlock :- 1
				end if

				if(nBlock < me.m_ncDataBlock - 2 & me.m_byBlockMode[nBlock + 2] = @QR_MODE_8BIT)
					{結合するブロックの後ろにある８ビットバイトモードブロックを結合}
					do me.m_nBlockLength[nBlock + 1] :+ me.m_nBlockLength[nBlock + 2]

					{後続をシフト}
					for i(nBlock + 2, me.m_ncDataBlock - 2)
						do me.m_byBlockMode[i]  :: me.m_byBlockMode[i + 1]
						do me.m_nBlockLength[i] :: me.m_nBlockLength[i + 1]
					end for

					do me.m_ncDataBlock :- 1
				end if

				do me.m_byBlockMode[nBlock] :: @QR_MODE_8BIT
				do me.m_nBlockLength[nBlock] :+ me.m_nBlockLength[nBlock + 1]

				{後続をシフト}
				for i(nBlock + 1, me.m_ncDataBlock - 2)
					do me.m_byBlockMode[i]  :: me.m_byBlockMode[i + 1]
					do me.m_nBlockLength[i] :: me.m_nBlockLength[i + 1]
				end for

				do me.m_ncDataBlock :- 1

				{結合したブロックの前から再調査}
				if(nBlock >= 1)
					do nBlock :- 1
				end if
				continue a
			end if

			do nBlock :+ 1 {次ブロックを調査}
		end while

		{ビット配列化}
		var ncComplete: int :: 0 {処理済データカウンタ}
		var wBinCode: byte16

		do me.m_ncDataCodeWordBit :: 0 {ビット単位処理カウンタ}

		{ do ZeroMemory(me.m_byDataCodeWord, @MAX_DATACODEWORD) }
		do me.m_byDataCodeWord :: #[@MAX_DATACODEWORD]byte8 {入力データエンコードエリア}

		var i: int :: 0
		while(i < me.m_ncDataBlock & me.m_ncDataCodeWordBit <> -1)
			if(me.m_byBlockMode[i] = @QR_MODE_NUMERAL) {数字モード}
				{インジケータ(0001b)}
				do me.m_ncDataCodeWordBit :: me.SetBitStream(me.m_ncDataCodeWordBit, 1 $ byte16, 4)
				{文字数セット}
				do me.m_ncDataCodeWordBit :: me.SetBitStream(me.m_ncDataCodeWordBit, me.m_nBlockLength[i] $ byte16, @nIndicatorLenNumeral[nVerGroup])
				{ビット列保存}
				for j(0, me.m_nBlockLength[i] - 1, 3)
					if(j < me.m_nBlockLength[i] - 2)
						do wBinCode :: (  ((lpsSource[ncComplete + j    ] $ int - '0' $ int) * 100) + {
						} ((lpsSource[ncComplete + j + 1] $ int - '0' $ int) *  10) + {
						}  (lpsSource[ncComplete + j + 2] $ int - '0' $ int)) $ byte16
						do me.m_ncDataCodeWordBit :: me.SetBitStream(me.m_ncDataCodeWordBit, wBinCode, 10)
					elif(j = me.m_nBlockLength[i] - 2)
						{端数２バイト}
						do wBinCode :: (  ((lpsSource[ncComplete + j    ] $ int - '0' $ int) *  10) + {
						}  (lpsSource[ncComplete + j + 1] $ int - '0' $ int)) $ byte16
						do me.m_ncDataCodeWordBit :: me.SetBitStream(me.m_ncDataCodeWordBit, wBinCode,  7)
					elif(j = me.m_nBlockLength[i] - 1)
						{端数１バイト}
						do wBinCode ::     (lpsSource[ncComplete + j    ] $ int - '0' $ int) $ byte16
						do me.m_ncDataCodeWordBit :: me.SetBitStream(me.m_ncDataCodeWordBit, wBinCode,  4)
					end if
				end for
				do ncComplete :+ me.m_nBlockLength[i]

			elif(me.m_byBlockMode[i] = @QR_MODE_ALPHABET) {英数字モード}
				{モードインジケータ(0010b)}
				do me.m_ncDataCodeWordBit :: me.SetBitStream(me.m_ncDataCodeWordBit, 2 $ byte16, 4)
				{文字数セット}
				do me.m_ncDataCodeWordBit :: me.SetBitStream(me.m_ncDataCodeWordBit, me.m_nBlockLength[i] $ byte16, @nIndicatorLenAlphabet[nVerGroup])
				{ビット列保存}
				for j(0, me.m_nBlockLength[i] - 1, 2)
					if(j < me.m_nBlockLength[i] - 1)
						do wBinCode :: ((me.AlphabetToBinaly(lpsSource[ncComplete + j    ]) * 45) + {
						}    me.AlphabetToBinaly(lpsSource[ncComplete + j + 1])) $ byte16
						do me.m_ncDataCodeWordBit :: me.SetBitStream(me.m_ncDataCodeWordBit, wBinCode, 11)
					else
						{端数１バイト}
						do wBinCode :: me.AlphabetToBinaly(lpsSource[ncComplete + j]) $ byte16

						do me.m_ncDataCodeWordBit :: me.SetBitStream(me.m_ncDataCodeWordBit, wBinCode, 6)
					end if
				end for
				do ncComplete :+ me.m_nBlockLength[i]
			elif(me.m_byBlockMode[i] = @QR_MODE_8BIT) {８ビットバイトモード}
				{モードインジケータ(0100b)}
				do me.m_ncDataCodeWordBit :: me.SetBitStream(me.m_ncDataCodeWordBit, 4 $ byte16, 4)
				{文字数セット}
				do me.m_ncDataCodeWordBit :: me.SetBitStream(me.m_ncDataCodeWordBit, me.m_nBlockLength[i] $ byte16, @nIndicatorLen8Bit[nVerGroup])
				{ビット列保存}
				for j(0, me.m_nBlockLength[i] - 1)
					do me.m_ncDataCodeWordBit :: me.SetBitStream(me.m_ncDataCodeWordBit, lpsSource[ncComplete + j] $ byte16, 8)
				end for
				do ncComplete :+ me.m_nBlockLength[i]
			else {me.m_byBlockMode[i] = @QR_MODE_KANJI} {漢字モード}
				{モードインジケータ(1000b)}
				do me.m_ncDataCodeWordBit :: me.SetBitStream(me.m_ncDataCodeWordBit, 8 $ byte16, 4)
				{文字数セット}
				do me.m_ncDataCodeWordBit :: me.SetBitStream(me.m_ncDataCodeWordBit, (me.m_nBlockLength[i] / 2) $ byte16, @nIndicatorLenKanji[nVerGroup])
				{漢字モードでビット列保存}
				for j(0, me.m_nBlockLength[i] - 1, 2)
					var wBinCode: byte16 :: me.KanjiToBinaly((lpsSource[ncComplete + j] $ byte16).Shl(8) + lpsSource[ncComplete + j] $ byte16)
					do me.m_ncDataCodeWordBit :: me.SetBitStream(me.m_ncDataCodeWordBit, wBinCode, 13)
				end for
				do ncComplete :+ me.m_nBlockLength[i]
			end if
			do i :+ 1
		end while

		return (me.m_ncDataCodeWordBit <> -1)
	end func

	{
	用  途：ビット長取得
	引  数：データモード種別、データ長、バージョン(型番)グループ
	戻り値：データビット長
	備  考：漢字モードでのデータ長引数は文字数ではなくバイト数
	}
	-func GetBitLength(nMode: byte8, ncData: int, nVerGroup: int): int
		var ncBits: int ::  0

		switch (nMode)
		case(@QR_MODE_NUMERAL)
			do ncBits :: 4 + @nIndicatorLenNumeral[nVerGroup] + (10 * (ncData / 3))
			switch(ncData % 3)
			case(1)
				do ncBits :+ 4
			case(2)
				do ncBits :+ 7
			default {case (0)}
			end switch
		case(@QR_MODE_ALPHABET)
			do ncBits :: 4 + @nIndicatorLenAlphabet[nVerGroup] + (11 * (ncData / 2)) + (6 * (ncData % 2))
		case(@QR_MODE_8BIT)
			do ncBits :: 4 + @nIndicatorLen8Bit[nVerGroup]     + ( 8 * ncData)
		default {case(@QR_MODE_KANJI)}
			do ncBits :: 4 + @nIndicatorLenKanji[nVerGroup]    + (13 * (ncData / 2))
		end switch

		return ncBits
	end func

	{
	用  途：ビットセット
	引  数：挿入位置、ビット配列データ、データビット長(最大16)
	戻り値：次回挿入位置(バッファオーバー時=-1)
	備  考：me.m_byDataCodeWord に結果をセット(要ゼロ初期化)
	}
	-func SetBitStream(nIndex: int, wData: byte16, ncData: int): int
		if(nIndex = -1 | nIndex + ncData > @MAX_DATACODEWORD * 8)
			return -1
		end if

		for i(0, ncData - 1)
			if(wData.And((1 $ byte16).Shl(ncData - i - 1)) <> 0 $ byte16)
				do me.m_byDataCodeWord[(nIndex + i) / 8] :: me.m_byDataCodeWord[(nIndex + i) / 8].Or((1 $ byte8).Shl(7 - ((nIndex + i) % 8)))
			end if
		end for

		return nIndex + ncData
	end func

	{
	用  途：数字モード該当チェック
	引  数：調査文字
	戻り値：該当時=true
	}
	-func IsNumeralData(c: byte8): bool
		switch(c $ char)
		case('0' to '9')
			return true
		end switch
		return false
	end func

	{
	用  途：英数字モード該当チェック
	引  数：調査文字
	戻り値：該当時=true
	}
	-func IsAlphabetData(c: byte8): bool
		switch(c $ char)
		case('0' to '9')
			return true
		case('A' to 'Z')
			return true
		case(' ',  '$',  '%',  '*',  '+',  '-',  '.',  '/',  ':')
			return true
		end switch
		return false
	end func

	{
	用  途：漢字モード該当チェック
	引  数：調査文字（16ビット文字）
	戻り値：該当時=true
	備  考：EBBFh 以降の S-JIS は対象外
	}
	-func IsKanjiData(c1: byte8, c2: byte8): bool
		if(   ((c1 >= 16#81 $ byte8 & c1 <= 16#9f $ byte8) | (c1 >= 16#e0 $ byte8 & c1 <= 16#eb $ byte8)) & (c2 >= 16#40 $ byte8))
			if((c1  = 16#9f $ byte8 & c2 >  16#fc $ byte8) | (c1  = 16#eb $ byte8 & c2 >  16#bf $ byte8))
				return false
			end if
			return true
		end if
		return false
	end func

	{
	用  途：英数字モード文字のバイナリ化
	引  数：対象文字
	戻り値：バイナリ値
	}
	-func AlphabetToBinaly(c: byte8): int
		switch(c $ char)
		case('0' to '9')
			return (c $ int - '0' $ int)
		case('A' to 'Z')
			return (c $ int - 'A' $ int + 10)
		case(' ')
			return 36
		case('$')
			return 37
		case('%')
			return 38
		case('*')
			return 39
		case('+')
			return 40
		case('-')
			return 41
		case('.')
			return 42
		case('/')
			return 43
		default
			return 44 {case(':')}
		end switch
	end func

	{
	用  途：漢字モード文字のバイナリ化
	引  数：対象文字
	戻り値：バイナリ値
	}
	-func KanjiToBinaly(wc: byte16): byte16
		switch(wc)
		case(16#8140 $ byte16 to 16#9ffc $ byte16)
			do wc :: (wc $ int - 16#8140) $ byte16
		default {case(16#e040 to 16#ebbf)}
			do wc :: (wc $ int - 16#c140) $ byte16
		end switch
		return wc.Shr(8) * 16#c0 $ byte16 + wc.And(16#00ff $ byte16)
	end func

	{
	用  途：ＲＳ誤り訂正コードワード取得
	引  数：データコードワードアドレス、データコードワード長、ＲＳコードワード長
	備  考：総コードワード分のエリアを確保してから呼び出し
	}
	-func GetRSCodeWord(lpbyRSWork: []byte8, ncDataCodeWord: int, ncRSCodeWord: int)
		for(0, ncDataCodeWord - 1)
			if(lpbyRSWork[0] <> @x00)
				var nExpFirst: byte8 :: @byIntToExp[lpbyRSWork[0] $ int] {初項係数より乗数算出}

				for j(0, ncRSCodeWord - 1)
					{各項乗数に初項乗数を加算（% 255 → α^255 = 1}
					var nExpElement: byte8 :: (((@byRSExp[ncRSCodeWord][j] + nExpFirst $ int)) % 255) $ byte8

					{排他論理和による剰余算出}
					do lpbyRSWork[j] :: lpbyRSWork[j + 1].Xor(@byExpToInt[nExpElement $ int])
				end for

				{残り桁をシフト}
				for j(ncRSCodeWord, ncDataCodeWord + ncRSCodeWord - 2)
					do lpbyRSWork[j] :: lpbyRSWork[j + 1]
				end for
			else
				{残り桁をシフト}
				for j(0, ncDataCodeWord + ncRSCodeWord - 2)
					do lpbyRSWork[j] :: lpbyRSWork[j + 1]
				end for
			end if
		end for
	end func

	{
	用  途：モジュールへのデータ配置
	戻り値：一辺のモジュール数
	}
	-func FormatModule()
		{ do ZeroMemory(me.m_byModuleData, sizeof(me.m_byModuleData)) }
		do me.m_byModuleData :: #[@MAX_MODULESIZE, @MAX_MODULESIZE]byte8

		{機能モジュール配置}
		do me.SetFunctionModule()

		{データパターン配置}
		do me.SetCodeWordPattern()

		if(me.m_nMaskingNo = -1)
			{最適マスキングパターン選択}
			do me.m_nMaskingNo :: 0

			do me.SetMaskingPattern(me.m_nMaskingNo) {マスキング}
			do me.SetFormatInfoPattern(me.m_nMaskingNo) {フォーマット情報パターン配置}

			var nMinPenalty: int :: me.CountPenalty()

			for i(1, 7)
				do me.SetMaskingPattern(i) {マスキング}
				do me.SetFormatInfoPattern(i) {フォーマット情報パターン配置}

				var nPenalty: int :: me.CountPenalty()

				if(nPenalty < nMinPenalty)
					do nMinPenalty :: nPenalty
					do me.m_nMaskingNo :: i
				end if
			end for
		end if

		do me.SetMaskingPattern(me.m_nMaskingNo) {マスキング}
		do me.SetFormatInfoPattern(me.m_nMaskingNo) {フォーマット情報パターン配置}

		{モジュールパターンをブール値に変換}
		for i(0, me.m_nSymbleSize - 1)
			for j(0, me.m_nSymbleSize - 1)
				do me.m_byModuleData[i][j] :: (me.m_byModuleData[i][j].And(@x11) <> @x00) $ byte8
			end for
		end for
	end func

	{
	用  途：機能モジュール配置
	備  考：フォーマット情報は機能モジュール登録のみ(実データは空白)
	}
	-func SetFunctionModule()
		{位置検出パターン}
		do me.SetFinderPattern(0, 0)
		do me.SetFinderPattern(me.m_nSymbleSize - 7, 0)
		do me.SetFinderPattern(0, me.m_nSymbleSize - 7)

		{位置検出パターンセパレータ}
		for i(0, 7)
			do me.m_byModuleData[i][7] :: @x20
			do me.m_byModuleData[7][i] :: @x20
			do me.m_byModuleData[me.m_nSymbleSize - 8    ][i] :: @x20
			do me.m_byModuleData[me.m_nSymbleSize - 8 + i][7] :: @x20
			do me.m_byModuleData[i][me.m_nSymbleSize - 8    ] :: @x20
			do me.m_byModuleData[7][me.m_nSymbleSize - 8 + i] :: @x20
		end for

		{フォーマット情報記述位置を機能モジュール部として登録}
		for i(0, 8)
			do me.m_byModuleData[i][8] :: @x20
			do me.m_byModuleData[8][i] :: @x20
		end for

		for i(0, 7)
			do me.m_byModuleData[me.m_nSymbleSize - 8 + i][8] :: @x20
			do me.m_byModuleData[8][me.m_nSymbleSize - 8 + i] :: @x20
		end for

		{バージョン情報パターン}
		do me.SetVersionPattern()

		{位置合わせパターン}
		for i(0, @QR_VersionInfo[me.m_nVersion].ncAlignPoint - 1)
			do me.SetAlignmentPattern(@QR_VersionInfo[me.m_nVersion].nAlignPoint[i], 6)
			do me.SetAlignmentPattern(6, @QR_VersionInfo[me.m_nVersion].nAlignPoint[i])

			for j(0, @QR_VersionInfo[me.m_nVersion].ncAlignPoint - 1)
				do me.SetAlignmentPattern(@QR_VersionInfo[me.m_nVersion].nAlignPoint[i], @QR_VersionInfo[me.m_nVersion].nAlignPoint[j])
			end for
		end for

		{タイミングパターン}
		for i(8, me.m_nSymbleSize - 9)
			do me.m_byModuleData[i][6] :: ((i % 2) = 0) ?(@x30, @x20)
			do me.m_byModuleData[6][i] :: ((i % 2) = 0) ?(@x30, @x20)
		end for
	end func

	{
	用  途：位置検出パターン配置
	引  数：配置左上座標
	}
	-func SetFinderPattern(x: int, y: int)
		var byPattern: []byte8 :: [16#7f $ byte8, {{1111111b}
								}  16#41 $ byte8, {{1000001b}
								}  16#5d $ byte8, {{1011101b}
								}  16#5d $ byte8, {{1011101b}
								}  16#5d $ byte8, {{1011101b}
								}  16#41 $ byte8, {{1000001b}
								}  16#7f $ byte8]  {1111111b}
		for i(0, 6)
			for j(0, 6)
				do me.m_byModuleData[x + j][y + i] :: (byPattern[i].And((1 $ byte8).Shl(6 - j)) <> @x00) ?(@x30, @x20)
			end for
		end for
	end func

	{
	用  途：位置合わせパターン配置
	引  数：配置中央座標
	}
	-func SetAlignmentPattern(x: int, y: int)
		var byPattern: []byte8 :: [16#1f $ byte8, {{11111b}
								}  16#11 $ byte8, {{10001b}
								}  16#15 $ byte8, {{10101b}
								}  16#11 $ byte8, {{10001b}
								}  16#1f $ byte8]  {11111b}
		if(me.m_byModuleData[x][y].And(@x20) <> @x00)
			return {機能モジュールと重複するため除外}
		end if

		{左上隅座標に変換}
		do x :- 2
		do y :- 2

		for i(0, 4)
			for j(0, 4)
				do me.m_byModuleData[x + j][y + i] :: (byPattern[i].And((1 $ byte8).Shl(4 - j)) <> @x00) ?(@x30, @x20)
			end for
		end for
	end func

	{
	用  途：バージョン(型番)情報パターン配置
	備  考：拡張ＢＣＨ(18,6)符号を誤り訂正として使用
	}
	-func SetVersionPattern()
		if(me.m_nVersion <= 6)
			return
		end if

		var nVerData: byte64 :: (me.m_nVersion $ byte64).Shl(12)

		{剰余ビット算出}
		for i(0, 5)
			if(nVerData.And((1 $ byte64).Shl(17 - i)) <> 0 $ byte64)
				do nVerData :: nVerData.Xor((16#1f25 $ byte64).Shl(5 - i))
			end if
		end for

		do nVerData :+ (me.m_nVersion $ byte64).Shl(12)

		for i(0, 5)
			for j(0, 2)
				do me.m_byModuleData[i][me.m_nSymbleSize - 11 + j] :: (nVerData.And((1 $ byte64).Shl(i * 3 + j)) <> 0 $ byte64) ?(@x30, @x20)
				do me.m_byModuleData[me.m_nSymbleSize - 11 + j][i] :: me.m_byModuleData[i][me.m_nSymbleSize - 11 + j]
			end for
		end for
	end func

	{
	用  途：データパターン配置
	}
	-func SetCodeWordPattern()
		var x: int :: me.m_nSymbleSize
		var y: int :: me.m_nSymbleSize - 1

		var nCoef_x:int :: 1 {ｘ軸配置向き}
		var nCoef_y:int :: 1 {ｙ軸配置向き}

		for i(0, me.m_ncAllCodeWord - 1)
			for j(0, 7)
				while(me.m_byModuleData[x][y].And(16#20 $ byte8) <> @x00, skip) {機能モジュールを除外}
					do x :+ nCoef_x
					do nCoef_x :* -1
					if(nCoef_x < 0)
						do y :+ nCoef_y
						if(y < 0 | y = me.m_nSymbleSize)
							do y :: (y < 0) ?(0, me.m_nSymbleSize - 1)
							do nCoef_y :* -1
							do x :- 2
							if(x = 6) {タイミングパターン}
								do x :- 1
							end if
						end if
					end if
				end while

				do me.m_byModuleData[x][y] :: (me.m_byAllCodeWord[i].And((1 $ byte8).Shl(7 - j)) <> @x00) ?(16#02 $ byte8, 16#00 $ byte8)
			end for
		end for
	end func

	{
	用  途：マスキングパターン配置
	引  数：マスキングパターン番号
	}
	-func SetMaskingPattern(nPatternNo: int)
		for i(0, me.m_nSymbleSize - 1)
			for j(0, me.m_nSymbleSize - 1)
				if(! (me.m_byModuleData[j][i].And(@x20) <> @x00)) {機能モジュールを除外}
					var bMask: bool
					switch (nPatternNo)
					case(0)
						do bMask :: ((i + j) % 2 = 0)
					case(1)
						do bMask :: (i % 2 = 0)
					case(2)
						do bMask :: (j % 3 = 0)
					case(3)
						do bMask :: ((i + j) % 3 = 0)
					case(4)
						do bMask :: (((i / 2) + (j / 3)) % 2 = 0)
					case(5)
						do bMask :: (((i * j) % 2) + ((i * j) % 3) = 0)
					case(6)
						do bMask :: ((((i * j) % 2) + ((i * j) % 3)) % 2 = 0)
					default {case(7)}
						do bMask :: ((((i * j) % 3) + ((i + j) % 2)) % 2 = 0)
					end switch
					do me.m_byModuleData[j][i] :: me.m_byModuleData[j][i].And(16#fe $ byte8).Or(((me.m_byModuleData[j][i].And(16#02 $ byte8) $ int > 1) $ byte8).Xor(bMask $ byte8))
				end if
			end for
		end for
	end func

	{
	用  途：フォーマット情報配置
	引  数：マスキングパターン番号
	}
	-func SetFormatInfoPattern(nPatternNo: int)
		var nFormatInfo: int

		switch(me.m_nLevel)
		case(@QR_LEVEL_M)
			do nFormatInfo :: 16#00 {00nnnb}
		case(@QR_LEVEL_L)
			do nFormatInfo :: 16#08 {01nnnb}
		case(@QR_LEVEL_Q)
			do nFormatInfo :: 16#18 {11nnnb}
		default {case(@QR_LEVEL_H)}
			do nFormatInfo :: 16#10 {10nnnb}
		end switch

		do nFormatInfo :+ nPatternNo

		var nFormatData: byte64 :: (nFormatInfo $ byte64).Shl(10)

		{剰余ビット算出}
		for i(0, 4)
			if(nFormatData.And((1 $ byte64).Shl(14 - i)) <> 0 $ byte64)
				do nFormatData :: nFormatData.Xor((16#0537 $ byte64).Shl(4 - i)) {10100110111b}
			end if
		end for

		do nFormatData :+ (nFormatInfo $ byte64).Shl(10)

		{マスキング}
		do nFormatData :: nFormatData.Xor(16#5412 $ byte64) {101010000010010b}

		{左上位置検出パターン周り配置}
		for i(0, 5)
			do me.m_byModuleData[8][i] :: (nFormatData.And((1 $ byte64).Shl(i)) <> 0 $ byte64) ?(@x30, @x20)
		end for

		do me.m_byModuleData[8][7] :: (nFormatData.And((1 $ byte64).Shl(6)) <> 0 $ byte64) ?(@x30, @x20)
		do me.m_byModuleData[8][8] :: (nFormatData.And((1 $ byte64).Shl(7)) <> 0 $ byte64) ?(@x30, @x20)
		do me.m_byModuleData[7][8] :: (nFormatData.And((1 $ byte64).Shl(8)) <> 0 $ byte64) ?(@x30, @x20)

		for i(9, 14)
			do me.m_byModuleData[14 - i][8] :: (nFormatData.And((1 $ byte64).Shl(i)) <> 0 $ byte64) ?(@x30, @x20)
		end for

		{右上位置検出パターン下配置}
		for i(0, 7)
			do me.m_byModuleData[me.m_nSymbleSize - 1 - i][8] :: (nFormatData.And((1 $ byte64).Shl(i)) <> 0 $ byte64) ?(@x30, @x20)
		end for

		{左下位置検出パターン右配置}
		do me.m_byModuleData[8][me.m_nSymbleSize - 8] :: @x30 {固定暗モジュール}

		for i(8, 14)
			do me.m_byModuleData[8][me.m_nSymbleSize - 15 + i] :: (nFormatData.And((1 $ byte64).Shl(i)) <> 0 $ byte64) ?(@x30, @x20)
		end for
	end func

	{
	用  途：マスク後ペナルティスコア算出
	}
	-func CountPenalty(): int
		var nPenalty: int :: 0

		{同色の列の隣接モジュール}
		for i(0, me.m_nSymbleSize - 1)
			for j(0, me.m_nSymbleSize - 5)
				var nCount: int :: 1

				var k: int
				for k_(j + 1, me.m_nSymbleSize - 1)
					do k :: k_
					if((me.m_byModuleData[i][j].And(@x11) = @x00) = ((me.m_byModuleData[i][k_].And(@x11) = @x00)))
						do nCount :+ 1
					else
						break k_
					end if
				end for

				if(nCount >= 5)
					do nPenalty :+ 3 + (nCount - 5)
				end if

				do j :: k - 1
			end for
		end for

		{同色の行の隣接モジュール}
		for i(0, me.m_nSymbleSize - 1)
			for j(0, me.m_nSymbleSize - 5)
				var nCount: int :: 1
				var k: int
				for k_(j + 1, me.m_nSymbleSize - 1)
					do k :: k_
					if((me.m_byModuleData[j][i].And(@x11) = @x00) = ((me.m_byModuleData[k_][i].And(@x11) = @x00)))
						do nCount :+ 1
					else
						break k_
					end if
				end for

				if(nCount >= 5)
					do nPenalty :+ 3 + (nCount - 5)
				end if

				do j :: k - 1
			end for
		end for

		{同色のモジュールブロック（２×２）}
		for i(0, me.m_nSymbleSize - 2)
			for j(0, me.m_nSymbleSize - 2)
				if(   ((me.m_byModuleData[i][j].And(@x11) = @x00) = (me.m_byModuleData[i + 1][j    ].And(@x11) = @x00)) & {
					} ((me.m_byModuleData[i][j].And(@x11) = @x00) = (me.m_byModuleData[i    ][j + 1].And(@x11) = @x00)) & {
					} ((me.m_byModuleData[i][j].And(@x11) = @x00) = (me.m_byModuleData[i + 1][j + 1].And(@x11) = @x00)))
					do nPenalty :+ 3
				end if
			end for
		end for

		{同一列における 1:1:3:1:1 比率（暗:明:暗:明:暗）のパターン}
		for i(0, me.m_nSymbleSize - 1)
			for j(0, me.m_nSymbleSize - 7)
				if(((j = 0) |					   (! (me.m_byModuleData[i][j - 1].And(@x11) <> @x00))) & {明 または シンボル外
												}  (   me.m_byModuleData[i][j    ].And(@x11) <> @x00)   & {暗 - 1
												}  (! (me.m_byModuleData[i][j + 1].And(@x11) <> @x00))  & {明 - 1
												}  (   me.m_byModuleData[i][j + 2].And(@x11) <> @x00)   & {暗 ┐
												}  (   me.m_byModuleData[i][j + 3].And(@x11) <> @x00)   & {暗 │3
												}  (   me.m_byModuleData[i][j + 4].And(@x11) <> @x00)   & {暗 ┘
												}  (! (me.m_byModuleData[i][j + 5].And(@x11) <> @x00))  & {明 - 1
												}  (   me.m_byModuleData[i][j + 6].And(@x11) <> @x00)   & {暗 - 1
				}    ((j = me.m_nSymbleSize - 7) | (! (me.m_byModuleData[i][j + 7].And(@x11) <> @x00))))  {明 または シンボル外}
					{前または後に4以上の明パターン}
					if(  ((j < 2 | ! (me.m_byModuleData[i][j - 2].And(@x11) <> @x00)) & {
						} (j < 3 | ! (me.m_byModuleData[i][j - 3].And(@x11) <> @x00)) & {
						} (j < 4 | ! (me.m_byModuleData[i][j - 4].And(@x11) <> @x00))) | {
						} ((j >= me.m_nSymbleSize -  8 | ! (me.m_byModuleData[i][j +  8].And(@x11) <> @x00)) & {
						}  (j >= me.m_nSymbleSize -  9 | ! (me.m_byModuleData[i][j +  9].And(@x11) <> @x00)) & {
						}  (j >= me.m_nSymbleSize - 10 | ! (me.m_byModuleData[i][j + 10].And(@x11) <> @x00))))
						do nPenalty :+ 40
					end if
				end if
			end for
		end for

		{同一行における 1:1:3:1:1 比率（暗:明:暗:明:暗）のパターン}
		for i(0, me.m_nSymbleSize - 1)
			for j(0, me.m_nSymbleSize - 7)
				if(((j = 0) |					  (! (me.m_byModuleData[j - 1][i].And(@x11) <> @x00))) & {明 または シンボル外
												} (   me.m_byModuleData[j    ][i].And(@x11) <> @x00)   & {暗 - 1
												} (! (me.m_byModuleData[j + 1][i].And(@x11) <> @x00))  & {明 - 1
												} (   me.m_byModuleData[j + 2][i].And(@x11) <> @x00)   & {暗 ┐
												} (   me.m_byModuleData[j + 3][i].And(@x11) <> @x00)   & {暗 │3
												} (   me.m_byModuleData[j + 4][i].And(@x11) <> @x00)   & {暗 ┘
												} (! (me.m_byModuleData[j + 5][i].And(@x11) <> @x00))  & {明 - 1
												} (   me.m_byModuleData[j + 6][i].And(@x11) <> @x00)   & {暗 - 1
				}   ((j = me.m_nSymbleSize - 7) | (! (me.m_byModuleData[j + 7][i].And(@x11) <> @x00))))  {明 または シンボル外}
					{前または後に4以上の明パターン}
					if(  ((j < 2 | ! (me.m_byModuleData[j - 2][i].And(@x11) <> @x00)) & {
						} (j < 3 | ! (me.m_byModuleData[j - 3][i].And(@x11) <> @x00)) & {
						} (j < 4 | ! (me.m_byModuleData[j - 4][i].And(@x11) <> @x00))) | {
						} ((j >= me.m_nSymbleSize -  8 | ! (me.m_byModuleData[j +  8][i].And(@x11) <> @x00)) & {
						}  (j >= me.m_nSymbleSize -  9 | ! (me.m_byModuleData[j +  9][i].And(@x11) <> @x00)) & {
						}  (j >= me.m_nSymbleSize - 10 | ! (me.m_byModuleData[j + 10][i].And(@x11) <> @x00))))
						do nPenalty :+ 40
					end if
				end if
			end for
		end for

		{全体に対する暗モジュールの占める割合}
		var nCount: int :: 0
		for i(0, me.m_nSymbleSize - 1)
			for j(0, me.m_nSymbleSize - 1)
				if(! (me.m_byModuleData[i][j].And(@x11) <> @x00))
					do nCount :+ 1
				end if
			end for
		end for

		do nPenalty :+ ((50 - ((nCount * 100) / (me.m_nSymbleSize * me.m_nSymbleSize))).Abs() / 5) * 10
		return nPenalty
	end func

	func ToStr(): []char
		var ret: []char :: ""
		for y(0, me.m_nSymbleSize - 1)
			for x(0, me.m_nSymbleSize - 1)
				if(me.m_byModuleData[x][y] <> @x00)
					do ret :~ "0"
				else
					do ret :~ " "
				end if
			end for
			do ret :~ "\n"
		end for
		return ret
	end func

	func Draw(x0: float, y0: float, size: float, bCellSizeMode: bool)
		var cellSize: float
		if(bCellSizeMode)
			do cellSize :: size
		else
			do cellSize :: size / (me.m_nSymbleSize + 2 * @QR_MARGIN) $ float
		end if
		do Draw@Rect(x0, y0, (me.m_nSymbleSize + 2 * @QR_MARGIN) $ float * cellSize, (me.m_nSymbleSize + 2 * @QR_MARGIN) $ float * cellSize, 1.0, 1.0, 1.0, 1.0)
		for x(0, me.m_nSymbleSize - 1)
			for y(0, me.m_nSymbleSize - 1)
				if(me.m_byModuleData[x][y] <> @x00)
					do Draw@Rect(x0 + (x + @QR_MARGIN) $ float * cellSize, y0 + (y + @QR_MARGIN) $ float * cellSize, cellSize, cellSize, 0.0, 0.0, 0.0, 1.0)
				else
					do Draw@Rect(x0 + (x + @QR_MARGIN) $ float * cellSize, y0 + (y + @QR_MARGIN) $ float * cellSize, cellSize, cellSize, 1.0, 1.0, 1.0, 1.0)
				end if
			end for
		end for
	end func
end class

-func min(a: int, b: int): int
	return (a < b) ?(a, b)
end func

-func memmove(toByte8s: []byte8, fromByte8s: []byte8, startIndex: int, num: int)
	var i: int :: 0
	for j(startIndex, startIndex + num - 1)
		do toByte8s[i] :: fromByte8s[j]
		do i :+ 1
	end for
end func
